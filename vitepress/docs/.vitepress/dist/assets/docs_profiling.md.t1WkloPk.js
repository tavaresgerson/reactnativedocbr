import{_ as e,c as a,o,a4 as r}from"./chunks/framework.nQaBHiNx.js";const h=JSON.parse('{"title":"Perfil","description":"","frontmatter":{},"headers":[],"relativePath":"docs/profiling.md","filePath":"docs/profiling.md"}'),d={name:"docs/profiling.md"},s=r('<h1 id="perfil" tabindex="-1">Perfil <a class="header-anchor" href="#perfil" aria-label="Permalink to &quot;Perfil&quot;">​</a></h1><p>Use o criador de perfil integrado para obter informações detalhadas sobre o trabalho realizado no thread JavaScript e no thread principal lado a lado. Acesse-o selecionando &quot;Perf Monitor&quot; no menu Debug.</p><p>Para iOS, Instruments é uma ferramenta inestimável, e no Android você deve aprender a usar o <code>systrace</code>.</p><p>Mas primeiro, certifique-se de que o <a href="/docs/performance.html">Modo de Desenvolvimento esteja DESLIGADO!</a> Você deverá ver <code>__DEV__ === false</code>, o aviso em nível de desenvolvimento está DESATIVADO e as otimizações de desempenho estão ATIVADAS nos logs do seu aplicativo.</p><p>Outra maneira de criar o perfil do JavaScript é usar o criador de perfil do Chrome durante a depuração. Isso não fornecerá resultados precisos, pois o código está sendo executado no Chrome, mas fornecerá uma ideia geral de onde podem estar os gargalos. Execute o criador de perfil na guia <code>Desempenho</code> do Chrome. Um gráfico em degradê aparecerá em <code>User Timing</code>. Para ver mais detalhes em formato tabular, clique na guia <code>Bottom Up</code> abaixo e selecione <code>DedicatedWorker Thread</code> no menu superior esquerdo.</p><h2 id="criacao-de-perfil-de-desempenho-da-interface-do-android-com-systrace" tabindex="-1">Criação de perfil de desempenho da interface do Android com <code>systrace</code> <a class="header-anchor" href="#criacao-de-perfil-de-desempenho-da-interface-do-android-com-systrace" aria-label="Permalink to &quot;Criação de perfil de desempenho da interface do Android com `systrace`&quot;">​</a></h2><p>O Android suporta mais de 10 mil telefones diferentes e é generalizado para suportar renderização de software: a arquitetura da estrutura e a necessidade de generalizar para muitos alvos de hardware, infelizmente significam que você recebe menos de graça, em relação ao iOS. Mas às vezes há coisas que você pode melhorar - e muitas vezes não é culpa do código nativo!</p><p>O primeiro passo para depurar essa instabilidade é responder à questão fundamental de onde seu tempo está sendo gasto durante cada quadro de 16 ms. Para isso, usaremos uma ferramenta padrão de criação de perfil do Android chamada <code>systrace</code>.</p><p><code>systrace</code> é uma ferramenta de criação de perfil padrão baseada em marcadores do Android (e é instalada quando você instala o pacote de ferramentas da plataforma Android). Os blocos de código perfilados são cercados por marcadores de início/fim que são visualizados em um formato de gráfico colorido. Tanto o Android SDK quanto a estrutura React Native fornecem marcadores padrão que você pode visualizar.</p><h3 id="_1-coletando-um-rastro" tabindex="-1">1. Coletando um rastro <a class="header-anchor" href="#_1-coletando-um-rastro" aria-label="Permalink to &quot;1. Coletando um rastro&quot;">​</a></h3><p>Primeiro, conecte um dispositivo que exiba as telas que você deseja investigar ao seu computador via USB e leve-o ao ponto logo antes da navegação/animação que você deseja criar o perfil. Execute o systrace da seguinte maneira:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ &lt;path_to_android_sdk&gt;/platform-tools/systrace/systrace.py --time=10 -o trace.html sched gfx view -a &lt;your_package_name&gt;</span></span></code></pre></div><p>Uma análise rápida deste comando:</p><ul><li><code>time</code> é o período de tempo que o rastreamento será coletado em segundos</li><li><code>sched</code>, <code>gfx</code> e <code>view</code> são as tags Android SDK (coleções de marcadores) com as quais nos preocupamos: <code>sched</code> fornece informações sobre o que está sendo executado em cada núcleo do seu telefone, <code>gfx</code> fornece informações gráficas, como limites de quadros, e <code>view</code> fornece informações sobre medir, fazer o layout e desenhar passes</li><li><code>-a &lt;your_package_name&gt;</code> habilita marcadores específicos do aplicativo, especificamente aqueles integrados à estrutura React Native. <code>your_package_name</code> pode ser encontrado no <code>AndroidManifest.xml</code> do seu aplicativo e se parece com <code>com.example.app</code></li></ul><p>Assim que o rastreamento começar a ser coletado, execute a animação ou interação de seu interesse. No final do rastreamento, o systrace fornecerá um link para o rastreamento que você pode abrir em seu navegador.</p><h3 id="_2-lendo-o-rastreamento" tabindex="-1">2. Lendo o rastreamento <a class="header-anchor" href="#_2-lendo-o-rastreamento" aria-label="Permalink to &quot;2. Lendo o rastreamento&quot;">​</a></h3><p>Depois de abrir o rastreamento em seu navegador (de preferência Chrome), você deverá ver algo assim:</p><p><img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/c59779f3-75ba-44fc-8ed5-fa8792f7aefd" alt="image"></p><blockquote><p><strong>DICA</strong> Use as teclas WASD para guiar e ampliar.</p></blockquote><p>Se o arquivo <code>.html</code> de rastreamento não estiver abrindo corretamente, verifique o seguinte no console do navegador:</p><p><img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/dde28dd2-2315-43b5-8443-ca0a94978153" alt="image"></p><p>Como <code>Object.observe</code> foi descontinuado em navegadores recentes, pode ser necessário abrir o arquivo na ferramenta de rastreamento do Google Chrome. Você pode fazer isso:</p><ul><li>Aba de abertura no chrome <code>chrome://tracing</code></li><li>Selecionando <em>load</em></li><li>Selecionando o arquivo html gerado a partir do comando anterior.</li></ul><blockquote><p><strong>ATIVAR HIGHLIGHT VSYNC</strong> Marque esta caixa de seleção no canto superior direito da tela para destacar os limites do quadro de 16ms: <img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/53bd7a9c-5ebb-4aca-b743-e19695e634a4" alt="image"></p><p>Você deverá ver listras de zebra como na imagem acima. Caso contrário, tente criar um perfil em um dispositivo diferente: sabe-se que a Samsung tem problemas para exibir vsyncs, enquanto a série Nexus é geralmente bastante confiável.</p></blockquote><h3 id="_3-encontre-o-seu-processo" tabindex="-1">3. Encontre o seu processo <a class="header-anchor" href="#_3-encontre-o-seu-processo" aria-label="Permalink to &quot;3. Encontre o seu processo&quot;">​</a></h3><p>Role até ver (parte do) nome do seu pacote. Nesse caso, eu estava criando o perfil de <code>com.facebook.adsmanager</code>, que aparece como <code>book.adsmanager</code> por causa de limites bobos de nomes de threads no kernel.</p><p>No lado esquerdo, você verá um conjunto de tópicos que correspondem às linhas da linha do tempo à direita. Existem alguns threads com os quais nos preocupamos para nossos propósitos: o thread de UI (que tem o nome do seu pacote ou o nome Thread de UI), <code>mqt_js</code> e <code>mqt_native_modules</code>. Se você estiver executando o Android 5+, também nos preocupamos com o Render Thread.</p><ul><li><p><strong>UI Thread</strong>. É aqui que acontece a medida/layout/desenho padrão do Android. O nome do tópico à direita será o nome do seu pacote (no meu caso <code>book.adsmanager</code>) ou UI Thread. Os eventos que você vê neste tópico devem ser parecidos com isto e têm a ver com <code>Choreographer</code>, <code>traversals</code> e <code>DispatchUI</code>: <img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/c5c57f20-09fb-4304-8a27-2775569d21ab" alt="image"></p></li><li><p><strong>JS Thread</strong>. É aqui que o JavaScript é executado. O nome do thread será <code>mqt_js</code> ou <code>&lt;...&gt;</code> dependendo de quão cooperativo o kernel do seu dispositivo está sendo. Para identificá-lo caso não tenha nome, procure coisas como <code>JSCall</code>, <code>Bridge.executeJSCall</code>, etc: <img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/5d1d1ce4-ed3a-4894-beba-dece57d3d5c0" alt="image"></p></li><li><p><strong>Native Modules Thread</strong>. É aqui que as chamadas do módulo nativo (por exemplo, o <code>UIManager</code>) são executadas. O nome do encadeamento será <code>mqt_native_modules</code> ou <code>&lt;...&gt;</code>. Para identificá-lo neste último caso, procure coisas como <code>NativeCall</code>, <code>callJavaModuleMethod</code> e <code>onBatchComplete</code>: <img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/9d69035c-4c44-47d1-a99d-ec70156c53bd" alt="image"></p></li><li><p><strong>Bônus: Thread Render</strong>. Se estiver usando Android L (5.0) e superior, você também terá uma thread de renderização em seu aplicativo. Esta thread gera os comandos OpenGL reais usados para desenhar sua UI. O nome do thread será <code>RenderThread</code> ou <code>&lt;...&gt;</code>. Para identificá-lo neste último caso, procure coisas como <code>DrawFrame</code> e <code>queueBuffer</code>:</p></li></ul><p><img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/49854aec-66d4-4d36-ba0b-98e22e87a1c7" alt="image"></p><h2 id="identificando-um-culpado" tabindex="-1">Identificando um culpado <a class="header-anchor" href="#identificando-um-culpado" aria-label="Permalink to &quot;Identificando um culpado&quot;">​</a></h2><p>Uma animação suave deve ser semelhante a esta:</p><p><img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/3b060561-91b8-4ee2-b650-fdf4d9eb3439" alt="image"></p><p>Cada mudança de cor é um quadro – lembre-se que para exibir um quadro, todo o nosso trabalho de UI precisa ser feito até o final desse período de 16 ms. Observe que nenhuma thread está funcionando próximo ao limite do quadro. Uma renderização de aplicativo como essa é renderizada a 60 FPS.</p><p>Se você notou um corte, no entanto, poderá ver algo assim:</p><p><img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/ec22d738-44a8-4e35-9c77-ff76e9761c75" alt="image"></p><p>Observe que o thread JS está em execução quase o tempo todo e além dos limites do quadro! Este aplicativo não está renderizando a 60 FPS. Neste caso, o problema está em JS.</p><p>Você também pode ver algo assim:</p><p><img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/132ef545-fe19-47fc-aa63-02ab501bc1fa" alt="image"></p><p>Nesse caso, a interface do usuário e as threads de renderização são os que têm trabalho cruzando os limites do quadro. A UI que estamos tentando renderizar em cada quadro está exigindo muito trabalho. Nesse caso, o problema está na renderização das visualizações nativas.</p><p>Neste ponto, você terá algumas informações muito úteis para orientar suas próximas etapas.</p><h2 id="resolvendo-problemas-de-javascript" tabindex="-1">Resolvendo problemas de JavaScript <a class="header-anchor" href="#resolvendo-problemas-de-javascript" aria-label="Permalink to &quot;Resolvendo problemas de JavaScript&quot;">​</a></h2><p>Se você identificou um problema de JS, procure pistas no JS específico que está executando. No cenário acima, vemos <code>RCTEventEmitter</code> sendo chamado várias vezes por quadro. Aqui está um zoom do thread JS do rastreamento acima:</p><p><img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/b631ef2b-c72c-4b27-8547-74caf0daca9b" alt="image"></p><p>Isso não parece certo. Por que está sendo chamado com tanta frequência? São realmente eventos diferentes? As respostas a essas perguntas provavelmente dependerão do código do seu produto. E muitas vezes, você vai querer dar uma olhada em <code>shouldComponentUpdate</code>.</p><h2 id="resolvendo-problemas-de-ui-nativa" tabindex="-1">Resolvendo problemas de UI nativa <a class="header-anchor" href="#resolvendo-problemas-de-ui-nativa" aria-label="Permalink to &quot;Resolvendo problemas de UI nativa&quot;">​</a></h2><p>Se você identificou um problema de UI nativa, geralmente há dois cenários:</p><ul><li>a IU que você está tentando desenhar cada quadro envolve muito trabalho na GPU ou</li><li>Você está construindo uma nova UI durante a animação/interação (por exemplo, carregando um novo conteúdo durante uma rolagem).</li></ul><h3 id="muito-trabalho-de-gpu" tabindex="-1">Muito trabalho de GPU <a class="header-anchor" href="#muito-trabalho-de-gpu" aria-label="Permalink to &quot;Muito trabalho de GPU&quot;">​</a></h3><p>No primeiro cenário, você verá um trace que tem o thread de UI e/ou Thread de Renderização parecido com este:</p><p><img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/a7ee7f32-8d5f-4c6b-8c07-1f3667fd7fff" alt="image"></p><p>Observe a longa quantidade de tempo gasto no <code>DrawFrame</code> que ultrapassa os limites do quadro. Este é o tempo gasto esperando que a GPU drene seu buffer de comando do quadro anterior.</p><p>Para mitigar isso, você deve:</p><ul><li>investigue usando <code>renderToHardwareTextureAndroid</code> para conteúdo estático e complexo que está sendo animado/transformado (por exemplo, animações de slide/alfa do Navigator)</li><li>certifique-se de não usar o <code>NeedOffscreenAlphaCompositing</code>, que está desabilitado por padrão, pois aumenta muito a carga por quadro na GPU na maioria dos casos.</li></ul><h3 id="criando-novas-visualizacoes-no-thread-da-ui" tabindex="-1">Criando novas visualizações no thread da UI <a class="header-anchor" href="#criando-novas-visualizacoes-no-thread-da-ui" aria-label="Permalink to &quot;Criando novas visualizações no thread da UI&quot;">​</a></h3><p>No segundo cenário, você verá algo mais parecido com isto:</p><p><img src="https://github.com/tavaresgerson/reactnativedocbr/assets/22455192/5a5de2c9-82f0-4ce2-a603-945d19006da6" alt="image"></p><p>Observe que primeiro o thread JS pensa um pouco, depois você vê algum trabalho realizado no thread de módulos nativos, seguido por uma travessia cara no thread de UI.</p><p>Não há uma maneira rápida de atenuar isso, a menos que você consiga adiar a criação de uma nova IU até depois da interação ou simplifique a IU que está criando. A equipe do React Native está trabalhando em uma solução de nível de infraestrutura para isso que permitirá que novas UI sejam criadas e configuradas fora do thread principal, permitindo que a interação continue sem problemas.</p>',58),t=[s];function i(c,n,m,p,u,l){return o(),a("div",null,t)}const g=e(d,[["render",i]]);export{h as __pageData,g as default};
