import{_ as e,c as o,o as a,a4 as s}from"./chunks/framework.nQaBHiNx.js";const q=JSON.parse('{"title":"Sistema de resposta por gestos","description":"","frontmatter":{},"headers":[],"relativePath":"docs/gesture-responder-system.md","filePath":"docs/gesture-responder-system.md"}'),t={name:"docs/gesture-responder-system.md"},r=s('<h1 id="sistema-de-resposta-por-gestos" tabindex="-1">Sistema de resposta por gestos <a class="header-anchor" href="#sistema-de-resposta-por-gestos" aria-label="Permalink to &quot;Sistema de resposta por gestos&quot;">​</a></h1><p>O sistema de resposta por gestos gerencia o ciclo de vida dos gestos no seu aplicativo. Um toque pode passar por diversas fases enquanto o app determina qual é a intenção do usuário. Por exemplo, o aplicativo precisa determinar se o toque está rolando, deslizando em um widget ou tocando. Isso pode até mudar durante um toque. Também pode haver vários toques simultâneos.</p><p>O sistema de resposta ao toque é necessário para permitir que os componentes negociem essas interações por toque sem qualquer conhecimento adicional sobre seus componentes pai ou filho.</p><h2 id="melhores-praticas" tabindex="-1">Melhores Práticas <a class="header-anchor" href="#melhores-praticas" aria-label="Permalink to &quot;Melhores Práticas&quot;">​</a></h2><p>Para que seu aplicativo seja ótimo, cada ação deve ter os seguintes atributos:</p><ul><li>Feedback/destaque – mostre ao usuário o que está acontecendo com seu toque e o que acontecerá quando ele liberar o gesto</li><li>Capacidade de cancelamento - ao realizar uma ação, o usuário deve ser capaz de abortá-la no meio do toque, arrastando o dedo para longe</li></ul><p>Esses recursos deixam os usuários mais confortáveis ao usar um aplicativo, pois permitem que as pessoas experimentem e interajam sem medo de cometer erros.</p><h2 id="touchablehighlight-and-touchable" tabindex="-1">TouchableHighlight and Touchable* <a class="header-anchor" href="#touchablehighlight-and-touchable" aria-label="Permalink to &quot;TouchableHighlight and Touchable*&quot;">​</a></h2><p>O sistema de resposta pode ser complicado de usar. Portanto, fornecemos uma implementação abstrata <code>Touchable</code> para coisas que deveriam ser &quot;tocáveis&quot;. Isso usa o sistema de resposta e permite configurar interações de toque de forma declarativa. Use <code>TouchableHighlight</code> em qualquer lugar onde você usaria um botão ou link na web.</p><h2 id="ciclo-de-vida-do-respondente" tabindex="-1">Ciclo de vida do Respondente <a class="header-anchor" href="#ciclo-de-vida-do-respondente" aria-label="Permalink to &quot;Ciclo de vida do Respondente&quot;">​</a></h2><p>Uma visualização pode se tornar a resposta ao toque, implementando os métodos de negociação corretos. Existem dois métodos para perguntar à visualização se ela deseja se tornar respondente:</p><ul><li><code>View.props.onStartShouldSetResponder: evt =&gt; true,</code> - Esta visualização deseja se tornar respondente no início de um toque?</li><li><code>View.props.onMoveShouldSetResponder: evt =&gt; true,</code> - Chamado para cada movimento de toque na Visualização quando não é o respondedor: esta visualização deseja &quot;reivindicar&quot; capacidade de resposta ao toque?</li></ul><p>Se a View retornar <code>true</code> e tentar se tornar o respondente, uma das seguintes situações acontecerá:</p><ul><li><code>View.props.onResponderGrant: evt =&gt; {}</code> - A visualização agora está respondendo a eventos de toque. Este é o momento de destacar e mostrar ao usuário o que está acontecendo</li><li><code>View.props.onResponderReject: evt =&gt; {}</code> - Outra coisa está respondendo agora e não irá liberá-la</li></ul><p>Se a visualização estiver respondendo, os seguintes manipuladores poderão ser chamados:</p><ul><li><code>View.props.onResponderMove: evt =&gt; {}</code> - O usuário está movendo o dedo</li><li><code>View.props.onResponderRelease: evt =&gt; {}</code> - Disparado no final do toque, ou seja, &quot;touchUp&quot;</li><li><code>View.props.onResponderTerminationRequest: evt =&gt; true</code> - Outra coisa deseja se tornar respondedor. Essa visão deve liberar o respondedor? Retornar verdadeiro permite a liberação</li><li><code>View.props.onResponderTerminate: evt =&gt; {}</code> - O respondente foi retirado da Visualização. Pode ser obtido por outras visualizações após uma chamada para <code>onResponderTerminationRequest</code> ou pode ser obtido pelo sistema operacional sem perguntar (acontece com o centro de controle/centro de notificação no iOS)</li></ul><p><code>evt</code> é um evento de toque sintético com o seguinte formato:</p><ul><li><code>nativeEvent</code><ul><li><code>changeTouches</code> - Matriz de todos os eventos de toque que foram alterados desde o último evento</li><li><code>identifier</code> - O ID do toque</li><li><code>locationX</code> - A posição X do toque, em relação ao elemento</li><li><code>locationY</code> - A posição Y do toque, em relação ao elemento</li><li><code>pageX</code> - A posição X do toque, em relação ao elemento raiz</li><li><code>pageY</code> - A posição Y do toque, em relação ao elemento raiz</li><li><code>target</code> - O ID do nó do elemento que recebe o evento de toque</li><li><code>timestamp</code> - Um identificador de tempo para o toque, útil para cálculo de velocidade</li><li><code>touches</code> - Matriz de todos os toques atuais na tela</li></ul></li></ul><h3 id="capturar-manipuladores-shouldset" tabindex="-1">Capturar manipuladores ShouldSet <a class="header-anchor" href="#capturar-manipuladores-shouldset" aria-label="Permalink to &quot;Capturar manipuladores ShouldSet&quot;">​</a></h3><p><code>onStartShouldSetResponder</code> e <code>onMoveShouldSetResponder</code> são chamados com um padrão de bolha, onde o nó mais profundo é chamado primeiro. Isso significa que o componente mais profundo se tornará respondedor quando múltiplas Views retornarem <code>true</code> para manipuladores <code>*ShouldSetResponder</code>. Isso é desejável na maioria dos casos, porque garante que todos os controles e botões possam ser usados.</p><p>No entanto, às vezes um pai vai querer ter certeza de que ele responderá. Isso pode ser resolvido usando a fase de captura. Antes que o sistema de resposta surja do componente mais profundo, ele fará uma fase de captura, disparando em <code>*ShouldSetResponderCapture</code>. Portanto, se uma visualização pai quiser evitar que o filho se torne respondedor em uma inicialização por toque, ela deverá ter um manipulador <code>onStartShouldSetResponderCapture</code> que retorne verdadeiro.</p><ul><li><code>View.props.onStartShouldSetResponderCapture: evt =&gt; true</code>,</li><li><code>View.props.onMoveShouldSetResponderCapture: evt =&gt; true</code>,</li></ul><h2 id="panresponder" tabindex="-1">PanResponder <a class="header-anchor" href="#panresponder" aria-label="Permalink to &quot;PanResponder&quot;">​</a></h2><p>Para interpretação de gestos de nível superior, confira <a href="/docs/panresponder.html">PanResponder</a>.</p>',24),d=[r];function i(n,u,p,l,c,m){return a(),o("div",null,d)}const v=e(t,[["render",i]]);export{q as __pageData,v as default};
